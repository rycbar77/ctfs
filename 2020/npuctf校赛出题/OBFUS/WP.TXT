0.翻找字符串列表寻找题目中特有字符,参考XREF交叉引用来到关键函数(其实就是main) 
1.把验证的全局数据2 dup(1E79h), 2135h, 170Dh, 1F41h, 1901h, 2CEDh, 11F9h, 2649h, 2581h, 2DB5h, 14B5h, 25E5h, 2A31h, 30D5h复制出来
2.分析数据解密循环
2.A 对数据的处理过多考虑到数据变形,进入各个函数分析,F0X5显然是幂计算,F0X1显然是GCD,F0X4为SUB运算符变形,F0X2为NOR,则F0X3为AND运算符变形
 .C 将数据依次由上个环节中得到的函数进行还原
 .B 发现循环中四个IF均为与数据无关的运算,显然是不透明谓词流程混淆,对数学表达式进行化简可以发现第一个IF和第三个IF永真,第二个IF与第四个IF永假.
 .D 去掉二,四IF,分析一,三IF,发现都是很简单的解密过程
 .E 依照上述过程分析更简短的验证循环,即可轻松得到全部流程
3.写出解密脚本
int nt_arry[]={0,7801,7801,8501,5901,8001,6401,11501,4601,9801,9601,11701,5301,9701,10801,12501,0}; 
	for(int i=1;i<=15;i++)
	{
		nt_arry[i]-=1;
		nt_arry[i]/=100;
		nt_arry[i]^=magic1[(i-1)%4];
		retn[i]=nt_arry[i]+magic1[(i-1)%4];
		printf("%c",retn[i]);		
	} 
	得到flag为NPUCTF{0bfu5er}
EX:搞不明白的短函数其实即使看不明白,直接复制出来一编译就能明白是在做什么了. 
